<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Melatonin Vibes - Dancin' Rhythm Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@300;400;600&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background: #e0c3fc;
            background: linear-gradient(135deg, #e0c3fc 0%, #8ec5fc 100%);
            font-family: 'Fredoka', sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
        }

        /* The YouTube iframe - styled to look like a music player widget */
        #video-wrapper {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 300px;
            height: 170px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 10px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.18);
            z-index: 20;
            transition: opacity 0.3s;
            pointer-events: none; /* Let clicks pass through if needed, but we want controls */
            pointer-events: auto;
        }

        #player {
            width: 100%;
            height: 100%;
            border-radius: 12px;
            opacity: 0.8;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 30;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 40px;
        }

        .hud-text {
            color: white;
            text-shadow: 0 4px 10px rgba(100, 100, 255, 0.3);
        }

        #score-display {
            font-size: 2rem;
            font-weight: 600;
        }

        #combo-display {
            font-size: 1.5rem;
            opacity: 0.8;
        }

        #feedback {
            position: absolute;
            top: 30%; /* Moved up slightly to not cover character */
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: bold;
            opacity: 0;
            transition: transform 0.1s, opacity 0.2s;
            color: #fff;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
        }

        /* Start Screen */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.4);
            backdrop-filter: blur(20px);
            z-index: 50;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s;
        }

        .btn-start {
            background: #6c5ce7;
            color: white;
            padding: 15px 40px;
            font-size: 1.5rem;
            border-radius: 50px;
            border: none;
            cursor: pointer;
            box-shadow: 0 10px 25px rgba(108, 92, 231, 0.4);
            transition: transform 0.2s, background 0.2s;
            font-family: 'Fredoka', sans-serif;
            pointer-events: auto;
        }

        .btn-start:hover {
            transform: scale(1.05);
            background: #5649c0;
        }

        .loading {
            font-size: 1.2rem;
            color: #6c5ce7;
            margin-bottom: 20px;
            font-weight: 600;
        }
        
        /* Hide UI when hidden class added */
        .hidden {
            opacity: 0;
            pointer-events: none !important;
        }

        /* Custom pulse animation for background elements */
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-20px); }
            100% { transform: translateY(0px); }
        }
    </style>
</head>
<body>

    <div id="game-container">
        <!-- YouTube Player Container -->
        <div id="video-wrapper">
            <div id="player"></div>
        </div>

        <!-- Canvas for Rendering Game -->
        <canvas id="gameCanvas"></canvas>

        <!-- Game UI -->
        <div id="ui-layer">
            <div class="flex justify-between items-start w-full">
                <div>
                    <div id="score-display" class="hud-text">Score: 0</div>
                    <div id="combo-display" class="hud-text">Combo: 0</div>
                </div>
                <div class="text-right hud-text opacity-70 text-sm">
                    <p>Song: Dancin (Krono Remix)</p>
                    <p>BPM: 120</p>
                    <p>Press SPACE or CLICK on beat</p>
                </div>
            </div>
            <div id="feedback">Perfect!</div>
        </div>

        <!-- Start Screen -->
        <div id="start-screen">
            <h1 class="text-5xl md:text-7xl font-bold text-[#6c5ce7] mb-4 tracking-tight text-center drop-shadow-sm">DREAM RHYTHM</h1>
            <p class="text-xl text-gray-600 mb-8 font-light max-w-md text-center">Relax. Listen. Catch the orbs with the beat.</p>
            <div id="loading-msg" class="loading">Loading Music...</div>
            <button id="start-btn" class="btn-start hidden" onclick="startGame()">Start Dreaming</button>
        </div>
    </div>

    <script>
        // --- Constants & Config ---
        const BPM = 120;
        const BEAT_INTERVAL = 60 / BPM; // Seconds per beat (0.5s)
        const TRAVEL_TIME_BEATS = 4; // How many beats it takes for an object to travel to target
        const AUDIO_OFFSET = 0.1; // Slight adjustment for audio/visual sync (seconds)
        const HIT_WINDOW = 0.15; // Seconds +/- to count as a hit
        
        // Colors
        const COLORS = {
            bg: '#e0c3fc',
            primary: '#6c5ce7', // Purple
            secondary: '#00cec9', // Teal
            accent: '#fd79a8', // Pink
            white: '#ffffff',
            grid: 'rgba(255,255,255,0.3)',
            skin: '#ffeaa7',
            hoodie: '#a29bfe',
            darkPurple: '#5649c0'
        };

        // --- Game State ---
        let isPlaying = false;
        let audioContextTime = 0;
        let startTime = 0;
        let lastBeat = 0;
        let score = 0;
        let combo = 0;
        let gameTime = 0;
        let notes = []; // Array of objects { beatTime, hit, visible }
        let particles = []; // Visual effects
        let zzzParticles = []; // Sleep particles
        
        // Canvas Setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- YouTube API Setup ---
        let player;
        let videoReady = false;

        // Load YouTube IFrame API asynchronously
        var tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        var firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

        function onYouTubeIframeAPIReady() {
            player = new YT.Player('player', {
                height: '100%',
                width: '100%',
                videoId: '6Nb-prB-4P0', // Dancin - Krono Remix
                playerVars: {
                    'playsinline': 1,
                    'controls': 0, // Hide controls for game feel
                    'disablekb': 1,
                    'fs': 0,
                    'start': 10 // Start 10 seconds in to skip silence/intro if needed
                },
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': onPlayerStateChange
                }
            });
        }

        function onPlayerReady(event) {
            videoReady = true;
            document.getElementById('loading-msg').classList.add('hidden');
            document.getElementById('start-btn').classList.remove('hidden');
        }

        function onPlayerStateChange(event) {
            // Sync game loop if video buffers
            if (event.data == YT.PlayerState.PLAYING) {
                // Resync logic could go here
            } else if (event.data == YT.PlayerState.PAUSED || event.data == YT.PlayerState.ENDED) {
                // isPlaying = false;
            }
        }

        // --- Game Loop & Logic ---

        function startGame() {
            if (!videoReady) return;
            
            document.getElementById('start-screen').classList.add('hidden');
            player.playVideo();
            
            // Initialize Game
            score = 0;
            combo = 0;
            notes = [];
            zzzParticles = [];
            updateScore();
            
            // Generate Notes Pattern
            // We'll generate notes procedurally for the song duration (~3 mins)
            // Pattern: Simple 4/4 beat with occasional off-beats or doubles
            let totalBeats = 120 * 3.5; // approx 3.5 mins
            
            // Wait a few seconds for intro before spawning
            for(let i = 8; i < totalBeats; i++) {
                // Basic Rhythm: Hit on every beat
                // Skip some to make it interesting
                if (Math.random() > 0.1) {
                    // Add some variation
                    if (i % 4 === 0) {
                        // Downbeat - always spawn
                        notes.push({ beatIndex: i, hit: false, type: 'beat' });
                    } else if (i % 8 === 7 && Math.random() > 0.5) {
                        // Double beat flair
                        notes.push({ beatIndex: i, hit: false, type: 'beat' });
                        notes.push({ beatIndex: i + 0.5, hit: false, type: 'offbeat' });
                    } else {
                        notes.push({ beatIndex: i, hit: false, type: 'beat' });
                    }
                }
            }

            isPlaying = true;
            requestAnimationFrame(gameLoop);
        }

        function gameLoop() {
            if (!isPlaying) return;

            // Sync Time
            // We use player.getCurrentTime() but smooth it because it doesn't update every frame
            const currentTime = player.getCurrentTime(); 
            
            if (currentTime) {
                gameTime = currentTime; 
            }

            updateLogic();
            render();
            
            requestAnimationFrame(gameLoop);
        }

        function updateLogic() {
            // Check for misses
            const currentBeat = gameTime / BEAT_INTERVAL;
            
            notes.forEach(note => {
                // If note passed the hit window and wasn't hit
                if (!note.hit && !note.missed && note.beatIndex < currentBeat - (HIT_WINDOW / BEAT_INTERVAL)) {
                    note.missed = true;
                    combo = 0;
                    showFeedback("Miss", '#ff7675');
                    updateScore();
                }
            });

            // Update particles (explosions)
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].life -= 0.02;
                particles[i].x += particles[i].vx;
                particles[i].y += particles[i].vy;
                if (particles[i].life <= 0) particles.splice(i, 1);
            }

            // Update Zzz particles
            // Spawn random Zs
            if (Math.random() < 0.02) {
                 zzzParticles.push({
                     x: width/2 + (Math.random() * 40 - 20),
                     y: height/2 - 50,
                     vx: Math.random() * 0.5 - 0.25,
                     vy: -0.5 - Math.random() * 0.5,
                     life: 1,
                     scale: 0
                 });
            }

            for (let i = zzzParticles.length - 1; i >= 0; i--) {
                zzzParticles[i].life -= 0.005;
                zzzParticles[i].x += zzzParticles[i].vx;
                zzzParticles[i].y += zzzParticles[i].vy;
                
                // Scale up then fade out
                if (zzzParticles[i].life > 0.8) zzzParticles[i].scale += 0.02;
                
                if (zzzParticles[i].life <= 0) zzzParticles.splice(i, 1);
            }
        }

        function inputAction(e) {
            if (!isPlaying) return;
            if (e.type === 'keydown' && e.code !== 'Space') return;
            
            e.preventDefault(); // Stop scrolling

            const currentBeat = gameTime / BEAT_INTERVAL;
            
            // Find closest hittable note
            let hitNote = null;
            let minDiff = Infinity;
            
            for (let note of notes) {
                if (note.hit || note.missed) continue;
                
                const diff = Math.abs(note.beatIndex - currentBeat);
                
                if (diff * BEAT_INTERVAL <= HIT_WINDOW) {
                    // This is a candidate
                    if (diff < minDiff) {
                        minDiff = diff;
                        hitNote = note;
                    }
                }
            }

            if (hitNote) {
                hitNote.hit = true;
                const timing = minDiff * BEAT_INTERVAL;
                
                // Scoring
                if (timing < 0.05) {
                    score += 100;
                    combo++;
                    showFeedback("Perfect!", COLORS.primary);
                    createExplosion(width/2, height/2, COLORS.primary);
                } else if (timing < 0.1) {
                    score += 50;
                    combo++;
                    showFeedback("Good", COLORS.secondary);
                    createExplosion(width/2, height/2, COLORS.secondary);
                } else {
                    score += 20;
                    combo++; // Keep combo but low score
                    showFeedback("Okay", COLORS.accent);
                }
                
                // Catch animation trigger - Character wake/bop
                catcher.scale = 1.2; // Bounce bigger
            } else {
                // Whiff
            }
            
            updateScore();
        }

        // Input Listeners
        window.addEventListener('keydown', inputAction);
        window.addEventListener('touchstart', inputAction);
        window.addEventListener('mousedown', inputAction);

        // --- Rendering ---

        // Animation helper
        const catcher = {
            baseScale: 1,
            scale: 1
        };

        function render() {
            // Clear
            ctx.clearRect(0, 0, width, height);

            const currentBeat = gameTime / BEAT_INTERVAL;
            const beatPhase = currentBeat % 1; // 0 to 1
            const pulse = Math.pow(1 - beatPhase, 3); // Strong at start of beat, fades

            // Draw dreamy background grid
            ctx.strokeStyle = COLORS.grid;
            ctx.lineWidth = 2;
            const gridSize = 100;
            const offset = (gameTime * 50) % gridSize;
            
            ctx.beginPath();
            for(let x = 0; x <= width; x += gridSize) {
                ctx.moveTo(x - offset, 0);
                ctx.lineTo(x - offset, height);
            }
            ctx.stroke();

            // --- Draw Character ---
            const cx = width / 2;
            const cy = height / 2;
            
            // Ease the catcher scale back to base
            catcher.scale += (catcher.baseScale - catcher.scale) * 0.1;
            
            // Bop the character on every beat even if not playing
            const beatBop = pulse * 0.05; 
            const finalScale = catcher.scale + beatBop;

            drawCharacter(ctx, cx, cy, finalScale);

            // --- Draw Zzz Particles ---
            zzzParticles.forEach(z => {
                ctx.globalAlpha = z.life;
                ctx.fillStyle = COLORS.white;
                ctx.font = `bold ${20 * z.scale}px 'Fredoka'`;
                ctx.fillText("Z", z.x, z.y);
            });
            ctx.globalAlpha = 1;

            // --- Draw Notes (Orbs) ---
            
            notes.forEach(note => {
                if (note.hit) return; // Don't draw hit notes

                const timeToHit = (note.beatIndex - currentBeat) * BEAT_INTERVAL;
                
                // Only draw if within visible range (e.g., 2 seconds out)
                if (timeToHit > -0.5 && timeToHit < 2) {
                    
                    // Calculate position: Fly from Right to Center
                    const x = cx + (timeToHit * 400); 
                    const y = cy; 
                    
                    // Visuals for the note
                    let alpha = 1;
                    if (note.missed) alpha = 0.5;

                    ctx.globalAlpha = alpha;
                    
                    // Bobbing effect based on time
                    const bob = Math.sin(gameTime * 8) * 15;
                    
                    drawOrb(ctx, x, y + bob, 20, note.type === 'offbeat' ? COLORS.accent : COLORS.secondary);
                    
                    ctx.globalAlpha = 1;
                }
            });

            // --- Draw Particles (Explosions) ---
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        function drawCharacter(ctx, x, y, scale) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(scale, scale);
            
            // We offset Y slightly so "center" is middle of head
            ctx.translate(0, 20);

            // 1. Hoodie Body (Rounded Bottom)
            ctx.fillStyle = COLORS.hoodie;
            ctx.beginPath();
            ctx.ellipse(0, 50, 60, 50, 0, Math.PI, 0); // Semi circleish
            ctx.fill();
            // Fill gap
            ctx.beginPath();
            ctx.rect(-60, 0, 120, 50);
            ctx.fill();

            // 2. Hoodie Head (Back)
            ctx.fillStyle = COLORS.darkPurple;
            ctx.beginPath();
            ctx.arc(0, 0, 55, 0, Math.PI * 2);
            ctx.fill();

            // 3. Face
            ctx.fillStyle = COLORS.skin;
            ctx.beginPath();
            ctx.arc(0, 5, 40, 0, Math.PI * 2);
            ctx.fill();
            
            // 4. Hoodie Rim (around face)
            ctx.strokeStyle = COLORS.hoodie;
            ctx.lineWidth = 10;
            ctx.beginPath();
            ctx.arc(0, 2, 50, 0.1, Math.PI - 0.1, true); // Arc around top
            ctx.stroke();

            // 5. Eyes (Closed/Sleeping)
            ctx.strokeStyle = '#2d3436';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            
            // Left Eye
            ctx.beginPath();
            ctx.moveTo(-20, 5);
            ctx.lineTo(-10, 10);
            ctx.lineTo(0, 5); // Wait, this is too close.
            ctx.stroke();
            
            // Simple curve eyes
            ctx.beginPath();
            ctx.arc(-15, 5, 8, 0, Math.PI, false); // Left
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(15, 5, 8, 0, Math.PI, false); // Right
            ctx.stroke();

            // 6. Headphones
            ctx.fillStyle = COLORS.secondary;
            // Left Ear Cup
            ctx.beginPath();
            ctx.ellipse(-55, 0, 15, 35, 0, 0, Math.PI * 2);
            ctx.fill();
            // Right Ear Cup
            ctx.beginPath();
            ctx.ellipse(55, 0, 15, 35, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Band
            ctx.strokeStyle = COLORS.secondary;
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.arc(0, -10, 55, Math.PI, 0);
            ctx.stroke();

            ctx.restore();
        }

        function drawOrb(ctx, cx, cy, radius, color) {
            // Glow
            ctx.shadowBlur = 20;
            ctx.shadowColor = color;
            
            // Core
            ctx.fillStyle = COLORS.white;
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Inner color ring
            ctx.shadowBlur = 0; // Reset for sharp lines
            ctx.fillStyle = color;
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.arc(cx, cy, radius * 0.8, 0, Math.PI * 2);
            ctx.fill();
            
            // Shine highlight
            ctx.fillStyle = COLORS.white;
            ctx.globalAlpha = 0.9;
            ctx.beginPath();
            ctx.arc(cx - radius*0.3, cy - radius*0.3, radius * 0.2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.globalAlpha = 1;
        }

        // --- UI & Effects ---

        function updateScore() {
            document.getElementById('score-display').innerText = `Score: ${score}`;
            document.getElementById('combo-display').innerText = `Combo: ${combo}`;
        }

        function showFeedback(text, color) {
            const el = document.getElementById('feedback');
            el.innerText = text;
            el.style.color = color;
            el.style.opacity = 1;
            el.style.transform = 'translate(-50%, -50%) scale(1.5)';
            
            // Reset animation
            setTimeout(() => {
                el.style.opacity = 0;
                el.style.transform = 'translate(-50%, -50%) scale(1)';
            }, 500);
        }

        function createExplosion(x, y, color) {
            for(let i=0; i<12; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    life: 1,
                    color: color,
                    size: Math.random() * 6 + 3
                });
            }
        }
        
    </script>
</body>
</html>
